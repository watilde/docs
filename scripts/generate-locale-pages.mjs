#!/usr/bin/env node

/**
 * Generate locale-specific page files for static export
 *
 * This script creates Japanese versions of all pages by:
 * 1. Finding all pages in src/pages
 * 2. Creating corresponding files in src/pages/ja/
 * 3. Re-exporting the original page component
 *
 * Run: node scripts/generate-locale-pages.mjs
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PAGES_DIR = path.join(__dirname, '../src/pages');
const JA_PAGES_DIR = path.join(__dirname, '../src/pages/ja');

// Pages/patterns to skip
const SKIP_PATTERNS = [
  /^_/, // _app.tsx, _document.tsx
  /^404/, // 404.tsx
  /^api\//, // API routes
  /^ja\// // Already in ja folder
];

function shouldSkip(relativePath) {
  return SKIP_PATTERNS.some((pattern) => pattern.test(relativePath));
}

function getRelativeImportPath(fromPath, toPath) {
  const relative = path.relative(path.dirname(fromPath), toPath);
  const posixPath = relative.split(path.sep).join('/');
  const withoutExt = posixPath.replace(/\.(tsx?|jsx?|mdx?)$/, '');
  return withoutExt.startsWith('.') ? withoutExt : './' + withoutExt;
}

function generateJaPage(originalPath, jaPath) {
  const importPath = getRelativeImportPath(jaPath, originalPath);
  const extension = path.extname(originalPath);

  let content;

  if (extension === '.mdx') {
    // For MDX files, just re-export
    content = `export { default } from '${importPath}';\n`;
  } else {
    // For TSX/JSX files, re-export everything
    content = `// Japanese locale version of this page
// Auto-generated by scripts/generate-locale-pages.mjs

export { default } from '${importPath}';

// Re-export data fetching functions if they exist
export * from '${importPath}';
`;
  }

  const jaDir = path.dirname(jaPath);
  if (!fs.existsSync(jaDir)) {
    fs.mkdirSync(jaDir, { recursive: true });
  }

  fs.writeFileSync(jaPath, content);
  const relativePath = path.relative(process.cwd(), jaPath);
  console.log(`âœ“ ${relativePath}`);
}

function walkDir(dir, callback, baseDir = dir) {
  const files = fs.readdirSync(dir);

  files.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);
    const relativePath = path.relative(baseDir, fullPath);

    if (stat.isDirectory()) {
      if (!shouldSkip(relativePath + '/')) {
        walkDir(fullPath, callback, baseDir);
      }
    } else if (stat.isFile()) {
      if (!shouldSkip(relativePath) && /\.(tsx?|jsx?|mdx?)$/.test(file)) {
        callback(fullPath, relativePath);
      }
    }
  });
}

console.log('ğŸŒ Generating Japanese locale pages...\n');

// Clean ja directory first (but keep index.tsx if it exists)
if (fs.existsSync(JA_PAGES_DIR)) {
  console.log('ğŸ—‘ï¸  Cleaning old ja pages...');
  fs.rmSync(JA_PAGES_DIR, { recursive: true, force: true });
}

// Create ja directory
fs.mkdirSync(JA_PAGES_DIR, { recursive: true });

// Generate ja pages
let count = 0;
walkDir(PAGES_DIR, (pagePath, relativePath) => {
  const jaPagePath = path.join(JA_PAGES_DIR, relativePath);
  generateJaPage(pagePath, jaPagePath);
  count++;
});

console.log(`\nâœ¨ Generated ${count} Japanese locale pages`);
console.log('ğŸ“ Location: src/pages/ja/');
console.log('\nâœ… Done! You can now run `yarn dev` or `yarn build`');
